import {CompiledModule} from './compiled-code';
import Executor from './executor';
import AnsiTerminalRuntimPlatform from './ansi-terminal-runtime-platform';
import ansiEscapes from 'ansi-escapes';

export class NodePlatform extends AnsiTerminalRuntimPlatform {
  print(s: string) {
    process.stdout.write(s);
  }

  async inputLine(): Promise<string> {
    return new Promise<string>((resolve) => {
      process.stdin.resume();
      process.stdin.once('data', (chunk) => {
        process.stdin.pause();
        resolve(chunk.toString());
      });
    });
  }

  async getChar(): Promise<string | null> {
    // Based on https://stackoverflow.com/a/35688423/3401268
    let result: string | null = null;
    process.stdin.resume();
    process.stdin.setRawMode(true);
    const cleanUp = () => {
      process.stdin.setRawMode(false);
      process.stdin.pause();
    };
    const callbackFn = (chunk: Buffer) => {
      result = chunk.toString()[0];
      cleanUp();
    };
    process.stdin.once('data', callbackFn);
    return new Promise<string | null>((resolve) => {
      setTimeout(() => {
        if (result === null) {
          process.stdin.removeListener('data', callbackFn);
          cleanUp();
        }
        resolve(result);
      }, 10);
    });
  }

  async getCursorPosition(): Promise<{x: number; y: number}> {
    // Based on https://github.com/bubkoo/get-cursor-position/blob/master/index.js
    process.stdin.resume();
    process.stdin.setRawMode(true);
    return new Promise<{x: number; y: number}>((resolve, reject) => {
      process.stdin.once('data', (chunk) => {
        const match = chunk.toString().match(/\[(\d+)\;(\d+)R/);
        if (match) {
          const [row, col] = [match[1], match[2]];
          resolve({
            // ANSI row & col numbers are 1-based.
            x: parseInt(col) - 1,
            y: parseInt(row) - 1,
          });
        } else {
          reject();
        }
      });
      process.stdout.write(ansiEscapes.cursorGetPosition);
    }).finally(() => {
      process.stdin.setRawMode(false);
      process.stdin.pause();
    });
  }

  async getScreenSize(): Promise<{rows: number; cols: number}> {
    // Basd on https://stackoverflow.com/a/35688423/3401268
    const origPos = await this.getCursorPosition();
    await this.moveCursorTo(10000, 10000);
    const bottomRightPos = await this.getCursorPosition();
    await this.moveCursorTo(origPos.x, origPos.y);
    return {
      rows: bottomRightPos.y + 1,
      cols: bottomRightPos.x + 1,
    };
  }
}

export class NodeExecutor extends Executor {
  constructor() {
    super(new NodePlatform());
  }
}

// Generated by codegen.
declare var compiledModule: CompiledModule | undefined;

async function run() {
  const executor = new NodeExecutor();
  return await executor.executeModule(compiledModule!);
}

export default {
  ...(typeof compiledModule === 'undefined' ? {} : compiledModule),
  run,
};

if (require.main === module) {
  run();
}
